module Interpreter where

-- Haskell module generated by the BNF converter

import AbsKotlin
import ErrM
import System.IO ( stdin, hGetContents )
import System.Environment ( getArgs, getProgName )
import System.Exit ( exitFailure, exitSuccess )
import Control.Monad (when)

import LexKotlin
import ParKotlin
import PrintKotlin
import AbsKotlin

import Data.Map
import Data.Map.Internal.Debug
type Result = Err String

--data BaseValue
--    = VInt Integer
--    | VString String
--    | VBool Bool
--    | VTupla [Value]
--    | VArray [Value]
--  deriving (Eq, Ord, Show, Read)

data Value
    = Vnull
    | VInt Integer
    | VString String
    | VBool Bool
    | VTupla [Value]
    | VArray [Value]
    | VFun [Arg] [Stm] Env
  deriving (Eq, Ord, Show, Read)

data Env = E (Map Ident Int)
  deriving (Eq, Ord, Show, Read)

data State = S (Map Int Value)
  deriving (Eq, Ord, Show, Read)


declare :: Env -> State -> Ident -> Value -> IO(Env, State)
declare (E em) (S sm) i v = do
    let index = size sm
    let ne = E (insert i index em)
    let ns = S (insert index v sm)
    return(ne,ns)

declareFun :: Env -> State -> Ident -> [Arg] -> [Stm] -> IO(Env, State)
declareFun (E em) (S sm) i a s = do
    let index = size sm
    let ne = E (insert i index em)
    let ns = S (insert index (VFun a s ne) sm)
    return(ne,ns)

--    podobnie moÅ¼na doFun
doMain :: [Stm] -> Env -> State -> IO(Env, State)
doMain stms e s = case stms of
  [] -> return(e,s)
  h:t -> do
      (ne, ns) <- transStm h e s
      doMain t ne ns





failure x = error ("Undefined case: " ++ show x)

transIdent :: Ident -> Result
transIdent x = case x of
  Ident string -> failure x

transProg :: Prog -> Env -> State -> IO()
transProg x (E em) (S sm) = case x of
  Program [] -> do
      putStrLn (Data.Map.Internal.Debug.showTree em)
      putStrLn (Data.Map.Internal.Debug.showTree sm)
  Program (h:t) -> do
      (ne, ns) <- transInst h (E em) (S sm)
      transProg (Program t) ne ns

transInst :: Inst -> Env -> State -> IO(Env, State)
transInst x = case x of
  Idec dec -> transDec dec

transDec :: Dec -> Env -> State -> IO(Env, State)
transDec x e s = case x of
  Dfun functiondec -> transFunctionDec functiondec e s
  Darray arraydec -> return(e,s)
  Dvar ident type_ exp -> return(e,s)
  Dval ident type_ exp -> return(e,s)
  Dvarnull ident type_ -> return(e,s)
  Dvalnull ident type_ -> return(e,s)

transEtuplaHelper :: [Exp] -> Env -> State -> IO(Env, State, [Value])
transEtuplaHelper exps e s = case exps of
  [] -> return(e, s, [])
  h:t -> do
      (ne, ns, nv) <- transExp h e s
      (nne, nns, nvs) <- transEtuplaHelper t ne ns
      return(nne, nns, nv:nvs)

transIntHelper :: Exp -> Exp -> (Integer -> Integer -> Integer) -> Env -> State -> IO(Env, State, Value)
transIntHelper exp1 exp2 f e s = do
    (ne, ns, VInt a) <- transExp exp1 e s
    (nne, nns, VInt b) <- transExp exp2 ne ns
    return(nne, nns, VInt (f a b))

transBoolHelper :: Exp -> Exp -> (Value -> Value -> Bool) -> Env -> State -> IO(Env, State, Value)
transBoolHelper exp1 exp2 f e s = do
    (ne, ns, a) <- transExp exp1 e s
    (nne, nns, b) <- transExp exp2 ne ns
    return(nne, nns, VBool (f a b))


transExp :: Exp -> Env -> State -> IO(Env, State, Value)
transExp x e s = case x of
  Eassign exp1 opassign exp2 -> failure x
  Eternary exp1 exp2 exp3 -> failure x
  Eor exp1 exp2 -> do
      (ne, ns, VBool a) <- transExp exp1 e s
      (nne, nns, VBool b) <- transExp exp2 ne ns
      return(nne, nns, VBool (a || b))
  Eand exp1 exp2 -> do
      (ne, ns, VBool a) <- transExp exp1 e s
      (nne, nns, VBool b) <- transExp exp2 ne ns
      return(nne, nns, VBool (a && b))
  Eeq exp1 exp2 -> transBoolHelper exp1 exp2 (==) e s
  Eneq exp1 exp2 -> transBoolHelper exp1 exp2 (/=) e s
  El exp1 exp2 -> transBoolHelper exp1 exp2 (<) e s
  Eg exp1 exp2 -> transBoolHelper exp1 exp2 (>) e s
  Ele exp1 exp2 -> transBoolHelper exp1 exp2 (<=) e s
  Ege exp1 exp2 -> transBoolHelper exp1 exp2 (>=) e s
  Eadd exp1 exp2 -> transIntHelper exp1 exp2 (+) e s
  Esub exp1 exp2 -> transIntHelper exp1 exp2 (-) e s
  Emul exp1 exp2 -> transIntHelper exp1 exp2 (*) e s
  Ediv exp1 exp2 -> do
      (ne, ns, a) <- transExp exp1 e s
      (nne, nns, b) <- transExp exp2 ne ns
      case (a, b) of
        (_, VInt 0) -> error "Cannot divide by 0"
        (VInt va, VInt vb) -> return(nne, nns, VInt (div va vb))
  Emod exp1 exp2 -> transIntHelper exp1 exp2 mod e s
  Eneg exp -> do
      (ne, ns, VBool a) <- transExp exp e s
      return(ne, ns, VBool (not a))
  Elneg exp -> failure x
  Einc exp -> failure x
  Edec exp -> failure x
  Etupla exps -> do
      (ne, ns, vs) <- transEtuplaHelper exps e s
      return(ne, ns, VTupla (reverse vs))
  Eint integer -> return(e, s, VInt integer)
  Estring string -> return(e, s, VString string)
  Etrue -> return(e, s, VBool True)
  Efalse -> return(e, s, VBool False)
  Enull -> return(e, s, Vnull)
  Ecall functionexp -> failure x
  Eget ident dimexps -> failure x
  Elambda lambda -> failure x
  Ennass exp -> failure x
  Ear ident -> failure x

transDimExp :: DimExp -> IO()
transDimExp x = case x of
  Dim exp -> failure x
transOpAssign :: OpAssign -> IO()
transOpAssign x = case x of
  OpAssign1 -> failure x
  OpAssign2 -> failure x
  OpAssign3 -> failure x
  OpAssign4 -> failure x
  OpAssign5 -> failure x
transBaseType :: BaseType -> IO()
transBaseType x = case x of
  Ttupla types -> failure x
  Tbool -> failure x
  Tint -> failure x
  Tstring -> failure x
transType :: Type -> IO()
transType x = case x of
  Tunit -> failure x
  Tnull basetype -> failure x
  Tnonnull basetype -> failure x
  Tfun types basetype -> failure x
transArg :: Arg -> IO()
transArg x = case x of
  Args ident type_ -> failure x


transStm :: Stm -> Env -> State -> IO(Env, State)
transStm x e s  = case x of
  Sdec dec -> failure x
  Sexp exp -> failure x
  Sblock stms -> failure x
  Sfor ident iterable stms -> failure x
  Swhile exp stms -> failure x
  Sbreak -> failure x
  Scont -> failure x
  Sretexp exp -> failure x
  Sret -> return(e,s)
  Sif exp stms -> failure x
  Sifelse exp stms1 stms2 -> failure x
--  print pokazuje tylko int lub string
  Sprint exp -> do
      (ne, ns, x) <- transExp exp e s
      case x of
        VInt v -> putStr (show v)
        VString v -> putStr (show v)
        VBool v -> putStr (show v)
      return(ne, ns)
  Sprintln exp -> do
      (ne, ns) <- transStm (Sprint exp) e s
      putStrLn ""
      return(ne, ns)
  Snotnull exp stm -> failure x


transFunctionDec :: FunctionDec -> Env -> State -> IO(Env, State)
transFunctionDec x e s = case x of
  FunDec (Ident "main") _ _ stms -> do
      (ne, ns) <- doMain stms e s
      return (e, ns)
--  FunDec (Ident "main") _ _ stms -> do
--      error "Function 'main' shloud look like:\n  fun main(): Unit { }"
--      return(e,s)
  FunDec ident args type_ stms -> declareFun e s ident args stms

transFunctionExp :: FunctionExp -> IO()
transFunctionExp x = case x of
  FunCall ident exps -> failure x

transLambda :: Lambda -> IO()
transLambda x = case x of
  LambdaRet args stms exp -> failure x
  LambdaNoRet args stms -> failure x
transIterable :: Iterable -> IO()
transIterable x = case x of
  Itarray ident -> failure x
  Itrange exp1 exp2 -> failure x
  Itup exp1 exp2 -> failure x
  Itdown exp1 exp2 -> failure x
  Itupst exp1 exp2 exp3 -> failure x
  Itdownst exp1 exp2 exp3 -> failure x
transArrayDec :: ArrayDec -> IO()
transArrayDec x = case x of
  ArrDec ident exp1 exp2 -> failure x

